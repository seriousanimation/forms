<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Quad Cylinder & Static Lighting</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            pointer-events: none;
        }

        select {
            pointer-events: auto;
            width: 100%;
            padding: 14px 20px;
            font-size: 18px;
            font-weight: 500;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(20, 20, 20, 0.85);
            color: white;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            text-align-last: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        .select-wrapper { position: relative; width: 100%; }
        .select-wrapper::after {
            content: 'â–¼'; font-size: 12px; color: #aaa;
            position: absolute; right: 20px; top: 50%;
            transform: translateY(-50%); pointer-events: none;
        }

        #loading {
            position: absolute; top: 40%; left: 50%; 
            transform: translate(-50%, -50%); color: #888;
        }
    </style>
</head>
<body>

    <div id="loading">Loading Reflection Map...</div>

    <div id="ui-container">
        <div class="select-wrapper">
            <select id="shapeSelect">
                <option value="cylinder">Cylinder (Quads)</option>
                <option value="cube">Cube</option>
                <option value="sphere">Sphere</option>
                <option value="cone">Cone</option>
                <option value="torus">Torus</option>
            </select>
        </div>

        <div class="select-wrapper">
            <select id="matSelect">
                <option value="matte" selected>Matte (Plastic)</option>
                <option value="reflective">Reflective (Chrome)</option>
                <option value="wood">Wood Texture</option>
                <option value="refractive">Refractive (Glass)</option>
            </select>
        </div>

        <div class="select-wrapper">
            <select id="wireSelect">
                <option value="shaded">Solid Shaded</option>
                <option value="wireframe">Wireframe</option>
            </select>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 7);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 2. LIGHTING (Attached to Camera for Static Screen Position) ---
        
        // Light A: Top Left (Low Sat Orange)
        // Hex #ffaa88 is a peachy/salmon orange (low saturation)
        const lightTopLeft = new THREE.DirectionalLight(0xffaa88, 3.0); 
        lightTopLeft.position.set(-5, 5, 2); // Left, Up, Front
        camera.add(lightTopLeft);

        // Light B: Bottom Right (Blue)
        const lightBottomRight = new THREE.DirectionalLight(0x0044ff, 3.0);
        lightBottomRight.position.set(5, -5, 2); // Right, Down, Front
        camera.add(lightBottomRight);

        // Add ambient light for general visibility
        const ambient = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambient);

        // IMPORTANT: Add camera to scene so the lights attached to it work
        scene.add(camera);

        // --- 3. ASSETS ---
        
        // Textures
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#5c4033'; ctx.fillRect(0,0,512,512);
            for(let i=0; i<80; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#8B4513' : '#a0522d';
                ctx.fillRect(Math.random()*512, 0, Math.random()*8, 512);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createPatternTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(0,0,512,512);
            ctx.beginPath();
            ctx.arc(256, 256, 180, 0, 2 * Math.PI);
            ctx.fillStyle = '#ef4444'; ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 4;
            ctx.strokeRect(10,10,492,492);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const rgbeLoader = new THREE.TextureLoader();
        rgbeLoader.load('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
            document.getElementById('loading').style.display = 'none';
        });

        // --- 4. GEOMETRY HELPERS ---

        // Custom Helper to build a Cylinder Wireframe out of QUADS
        function createQuadCylinderWireframe(radius, height, radialSegs, heightSegs) {
            const vertices = [];
            
            // 1. Vertical Lines (The Walls)
            for (let i = 0; i < radialSegs; i++) {
                const angle = (i / radialSegs) * Math.PI * 2;
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;
                // Line from bottom to top
                vertices.push(x, -height/2, z);
                vertices.push(x, height/2, z);
            }

            // 2. Horizontal Rings (The Ribs)
            // We include top and bottom caps in this loop
            for (let j = 0; j <= heightSegs; j++) {
                const y = -height/2 + (height * (j / heightSegs));
                
                // Draw a circle at this height
                for (let i = 0; i < radialSegs; i++) {
                    const angle1 = (i / radialSegs) * Math.PI * 2;
                    const angle2 = ((i + 1) / radialSegs) * Math.PI * 2;
                    
                    vertices.push(Math.sin(angle1) * radius, y, Math.cos(angle1) * radius);
                    vertices.push(Math.sin(angle2) * radius, y, Math.cos(angle2) * radius);
                }
            }

            // 3. Cap Spokes (Optional: connects center to edge to close the shape visually)
            // For a pure "Quad" look on caps, we'd need a grid, but radial spokes are standard for cylinders
            // Uncomment below if you want spokes on top/bottom
            /*
            [-height/2, height/2].forEach(y => {
                for (let i = 0; i < radialSegs; i++) {
                    const angle = (i / radialSegs) * Math.PI * 2;
                    vertices.push(0, y, 0); // Center
                    vertices.push(Math.sin(angle) * radius, y, Math.cos(angle) * radius); // Edge
                }
            });
            */

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            return geo;
        }

        const geometries = {
            cube: new THREE.BoxGeometry(2, 2, 2),
            cylinder: new THREE.CylinderGeometry(1, 1, 2.5, 32, 4), // 4 height segments
            sphere: new THREE.SphereGeometry(1.4, 32, 32),
            cone: new THREE.ConeGeometry(1.2, 2.5, 32, 4),
            torus: new THREE.TorusGeometry(1.1, 0.4, 32, 64)
        };

        // --- 5. MATERIALS ---
        const materials = {
            reflective: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.0, metalness: 1.0 }),
            matte: new THREE.MeshStandardMaterial({ map: createPatternTexture(), roughness: 0.5, metalness: 0.1 }),
            wood: new THREE.MeshStandardMaterial({ map: createWoodTexture(), roughness: 0.7 }),
            refractive: new THREE.MeshPhysicalMaterial({ roughness: 0.0, transmission: 1.0, thickness: 1.0, ior: 1.5, color: 0xffffff }),
            wireframeColor: new THREE.LineBasicMaterial({ color: 0xffffff })
        };

        // --- 6. UPDATE LOGIC ---
        
        let currentMesh = null;
        let currentLine = null;

        const shapeSelect = document.getElementById('shapeSelect');
        const matSelect = document.getElementById('matSelect');
        const wireSelect = document.getElementById('wireSelect');

        function updateScene() {
            if (currentMesh) { scene.remove(currentMesh); currentMesh = null; }
            if (currentLine) { scene.remove(currentLine); currentLine = null; }

            const shapeKey = shapeSelect.value;
            const matKey = matSelect.value;
            const mode = wireSelect.value;
            const geometry = geometries[shapeKey];

            // Render Solid
            if (mode === 'shaded') {
                const material = materials[matKey];
                currentMesh = new THREE.Mesh(geometry, material);
                scene.add(currentMesh);
            } 
            // Render Wireframe
            else {
                let wireGeo;

                if (shapeKey === 'cylinder') {
                    // USE CUSTOM QUAD GENERATOR
                    // matches geometry dimensions: radius 1, height 2.5, radial 32, heightSegs 4
                    wireGeo = createQuadCylinderWireframe(1, 2.5, 32, 4);
                    currentLine = new THREE.LineSegments(wireGeo, materials.wireframeColor);
                } 
                else if (shapeKey === 'cube') {
                    wireGeo = new THREE.EdgesGeometry(geometry); 
                    currentLine = new THREE.LineSegments(wireGeo, materials.wireframeColor);
                } 
                else {
                    // Fallback for sphere/torus/cone
                    wireGeo = new THREE.WireframeGeometry(geometry);
                    currentLine = new THREE.LineSegments(wireGeo, materials.wireframeColor);
                }

                if(currentLine) scene.add(currentLine);
            }
        }

        updateScene();

        // Listeners
        shapeSelect.addEventListener('change', updateScene);
        matSelect.addEventListener('change', updateScene);
        wireSelect.addEventListener('change', updateScene);

        // --- 7. LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
