<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Optimized 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            pointer-events: none;
        }

        select {
            pointer-events: auto;
            width: 100%;
            padding: 14px 20px;
            font-size: 18px;
            font-weight: 500;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(20, 20, 20, 0.85);
            color: white;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            text-align-last: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        .select-wrapper { position: relative; width: 100%; }
        .select-wrapper::after {
            content: 'â–¼'; font-size: 12px; color: #aaa;
            position: absolute; right: 20px; top: 50%;
            transform: translateY(-50%); pointer-events: none;
        }

        #loading {
            position: absolute; top: 40%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: #888;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing 3D Engine...</div>

    <div id="ui-container">
        <div class="select-wrapper">
            <select id="shapeSelect">
                <option value="cylinder">Cylinder (Quads)</option>
                <option value="cube">Cube</option>
                <option value="sphere">Sphere</option>
                <option value="cone">Cone</option>
                <option value="torus">Torus</option>
            </select>
        </div>

        <div class="select-wrapper">
            <select id="matSelect">
                <option value="matte" selected>Matte (Plastic)</option>
                <option value="reflective">Reflective (Chrome)</option>
                <option value="wood">Wood Texture</option>
                </select>
        </div>

        <div class="select-wrapper">
            <select id="wireSelect">
                <option value="shaded">Solid Shaded</option>
                <option value="wireframe">Wireframe</option>
            </select>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 7);
        scene.add(camera); // REQUIRED for camera-attached lights

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio at 2 for performance
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 2. STATIC LIGHTING (Attached to Camera) ---
        
        // Light A: Top Left (Orange)
        const lightTopLeft = new THREE.DirectionalLight(0xffaa88, 4.0); 
        lightTopLeft.position.set(-5, 5, 2); 
        camera.add(lightTopLeft);

        // Light B: Bottom Right (Blue)
        const lightBottomRight = new THREE.DirectionalLight(0x0044ff, 4.0);
        lightBottomRight.position.set(5, -5, 2); 
        camera.add(lightBottomRight);

        // Ambient for base visibility
        const ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);

        // --- 3. ASSETS ---
        
        // Wood Texture
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256; // Reduced texture size for mobile memory
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#5c4033'; ctx.fillRect(0,0,256,256);
            for(let i=0; i<40; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#8B4513' : '#a0522d';
                ctx.fillRect(Math.random()*256, 0, Math.random()*8, 256);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // Plastic Pattern Texture
        function createPatternTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(0,0,512,512);
            ctx.beginPath();
            ctx.arc(256, 256, 180, 0, 2 * Math.PI);
            ctx.fillStyle = '#ef4444'; ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 4;
            ctx.strokeRect(10,10,492,492);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // Environment Map (Optimized Loading)
        const textureLoader = new THREE.TextureLoader();
        // Standard JPG is much faster to load than HDR on mobile
        textureLoader.load('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg', 
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                const loading = document.getElementById('loading');
                if(loading) loading.style.opacity = 0;
            },
            undefined, // onProgress
            (err) => {
                console.error("Texture failed, using lights only");
                const loading = document.getElementById('loading');
                if(loading) loading.style.display = 'none';
            }
        );

        // --- 4. GEOMETRY HELPERS ---

        // Custom Quad Cylinder
        function createQuadCylinderWireframe(radius, height, radialSegs, heightSegs) {
            const vertices = [];
            
            // 1. Vertical Lines
            for (let i = 0; i < radialSegs; i++) {
                const angle = (i / radialSegs) * Math.PI * 2;
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;
                vertices.push(x, -height/2, z);
                vertices.push(x, height/2, z);
            }

            // 2. Horizontal Rings
            for (let j = 0; j <= heightSegs; j++) {
                const y = -height/2 + (height * (j / heightSegs));
                for (let i = 0; i < radialSegs; i++) {
                    const angle1 = (i / radialSegs) * Math.PI * 2;
                    const angle2 = ((i + 1) / radialSegs) * Math.PI * 2;
                    vertices.push(Math.sin(angle1) * radius, y, Math.cos(angle1) * radius);
                    vertices.push(Math.sin(angle2) * radius, y, Math.cos(angle2) * radius);
                }
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            return geo;
        }

        const geometries = {
            cube: new THREE.BoxGeometry(2, 2, 2),
            cylinder: new THREE.CylinderGeometry(1, 1, 2.5, 32, 4),
            sphere: new THREE.SphereGeometry(1.4, 32, 32),
            cone: new THREE.ConeGeometry(1.2, 2.5, 32, 4),
            torus: new THREE.TorusGeometry(1.1, 0.4, 32, 64)
        };

        // --- 5. MATERIALS ---
        const materials = {
            reflective: new THREE.MeshStandardMaterial({ 
                color: 0xffffff, roughness: 0.05, metalness: 1.0 // 0.05 roughness is cheaper than 0.0 on some GPUs
            }),
            matte: new THREE.MeshStandardMaterial({ 
                map: createPatternTexture(), roughness: 0.5, metalness: 0.1 
            }),
            wood: new THREE.MeshStandardMaterial({ 
                map: createWoodTexture(), roughness: 0.7 
            }),
            wireframeColor: new THREE.LineBasicMaterial({ color: 0xffffff })
        };

        // --- 6. LOGIC ---
        
        let currentMesh = null;
        let currentLine = null;

        const shapeSelect = document.getElementById('shapeSelect');
        const matSelect = document.getElementById('matSelect');
        const wireSelect = document.getElementById('wireSelect');

        function updateScene() {
            if (currentMesh) { scene.remove(currentMesh); currentMesh = null; }
            if (currentLine) { scene.remove(currentLine); currentLine = null; }

            const shapeKey = shapeSelect.value;
            const matKey = matSelect.value;
            const mode = wireSelect.value;
            const geometry = geometries[shapeKey];

            if (mode === 'shaded') {
                const material = materials[matKey];
                currentMesh = new THREE.Mesh(geometry, material);
                scene.add(currentMesh);
            } 
            else {
                let wireGeo;
                if (shapeKey === 'cylinder') {
                    wireGeo = createQuadCylinderWireframe(1, 2.5, 32, 4);
                } else if (shapeKey === 'cube') {
                    wireGeo = new THREE.EdgesGeometry(geometry); 
                } else {
                    wireGeo = new THREE.WireframeGeometry(geometry);
                }
                currentLine = new THREE.LineSegments(wireGeo, materials.wireframeColor);
                scene.add(currentLine);
            }
        }

        updateScene();

        shapeSelect.addEventListener('change', updateScene);
        matSelect.addEventListener('change', updateScene);
        wireSelect.addEventListener('change', updateScene);

        // --- 7. ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
